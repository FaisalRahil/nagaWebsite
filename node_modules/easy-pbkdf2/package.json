{
  "author": "",
  "name": "easy-pbkdf2",
  "version": "0.1.1",
  "description": "Easily generate securily salted PBKDF2 hashes for password storage",
  "keywords": [
    "pbkdf2",
    "password",
    "passwords",
    "salt",
    "security",
    "login",
    "auth",
    "authorization",
    "sign",
    "key",
    "hash"
  ],
  "main": "easy-pbkdf2.js",
  "scripts": {
    "test": "node test.js"
  },
  "homepage": "https://github.com/davidmurdoch/easy-pbkdf2",
  "bugs": {
    "url": "https://github.com/davidmurdoch/easy-pbkdf2/issues"
  },
  "dependencies": {
    "lodash": "1.3.1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/davidmurdoch/easy-pbkdf2.git"
  },
  "readme": "# Easy PBKDF2 for node.js\r\n\r\nEasy PBKDF2 makes it easier to create secure, individually salted, password hashes using PBKDF2.\r\n\r\nThis implementation is based on [StackExchange's own Open Sourced PBKDF2 methods](https://code.google.com/p/stackid/source/browse/OpenIdProvider/Current.cs#1257).\r\n\r\n## Installation:\r\n\r\nvia cmd line:\r\n\r\n```bash\r\n$ npm install easy-pbkdf2 --save\r\n```\r\n\r\nor in your `package.json`:\r\n\r\n```json\r\n\"dependencies\": {\r\n    \"easy-pbkdf2\": \"0.0.2\"\r\n}\r\n```\r\n\r\n## Usage:\r\n```js\r\nvar easyPbkdf2 = require(\"easy-pbkdf2\")();\r\nvar salt = easyPbkdf2.generateSalt(); // `salt` should be treated as opaque, as it captures iterations\r\nvar password = \"RandomDigits\";\r\neasyPbkdf2.secureHash( password, salt, function( err, passwordHash, originalSalt ) {\r\n    // use your own db's methods to save the hashed password AND salt.\r\n    currentUser.update({\r\n        // The Base64 encoded hash, 344 characters long\r\n        \"password_hash\": passwordHash,\r\n        // Salt length varies based on SALT_SIZE and iterations. The default SALT_SIZE of\r\n        // 32 produces a value that is:\r\n        // (hashIterations.toString(16).length) + 1 + base64EncodedSalt.length)\r\n        // characters long (42 characters).\r\n        \"salt\": originalSalt // === salt\r\n    });\r\n});\r\n\r\n// ...\r\n\r\n// sometime later:\r\nfunction authenticate( user, userEnteredPassword, callback ) {\r\n\t// make sure the user-entered password is equal to the previously\r\n    // created hash when hashed with the same salt.\r\n    easyPbkdf2.verify( user.salt, user.password_hash, userEnteredPassword, function( err, valid ) {\r\n        callback( valid );\r\n    });\r\n}\r\n```\r\n\r\nYou can also use EasyPbkdf2 to generate the salt for you by omitting the `salt` parameter:\r\n\r\n```js\r\neasyPbkdf2.secureHash( password, function( err, passwordHash, newSalt ) {\r\n    // save newSalt somewhere!\r\n});\r\n```\r\n\r\nTo create a new instance of `EasyPbkdf2`:\r\n\r\n```js\r\n    var easyPbkdf2 = require(\"easy-pbkdf2\")();\r\n```\r\n\r\nYou can also use the following methods of instantiation:\r\n\r\n```js\r\n// the EasyPbkdf2 constructor\r\nvar EasyPbkdf2 = require(\"easy-pbkdf2\"),\r\n    easyPbkdf2;\r\n\r\neasyPbkdf2 = EasyPbkdf2(options);\r\neasyPbkdf2 = new EasyPbkdf2(options);\r\neasyPbkdf2 = EasyPbkdf2.EasyPbkdf2(options);\r\neasyPbkdf2 = new EasyPbkdf2.EasyPbkdf2(options);\r\n```\r\n\r\nof which all will return an `EasyPbkdf2` instance with `options` set.\r\n\r\n## Options\r\n\r\n```js\r\n var options = {\r\n    // default DEFAULT_HASH_ITERATIONS is 512\r\n    \"DEFAULT_HASH_ITERATIONS\": 256,\r\n    // default SALT_SIZE is 32\r\n    \"SALT_SIZE\": 16,\r\n    // default KEY_LENGTH is 256\r\n    \"KEY_LENGTH\": 128\r\n};\r\n\r\nvar easyPbkdf2 = new EasyPbkdf2(options);\r\nconsole.log(easyPbkdf2.DEFAULT_HASH_ITERATIONS) // 256\r\nconsole.log(easyPbkdf2.SALT_SIZE); // 16\r\nconsole.log(easyPbkdf2.KEY_LENGTH); // 128\r\n\r\n// options are applied to each instance individually.\r\nconsole.log( (new EasyPbkdf2()).DEFAULT_HASH_ITERATIONS ); // 512\r\n```\r\n\r\n## Methods\r\n\r\n###`weakHash( value )`\r\n\r\n> Cranks out a collision resistant hash, relatively quickly.\r\n> Not suitable for passwords, or sensitive information.\r\n*Synchronous only*\r\n\r\n#### Params:\r\n - **value**: String or Object. Base64 encoded SHA-1 hash of `value`\r\n\r\n#### Returns:\r\n - A string; Base64 encoded SHA-1 hash of `value`\r\n\r\n---\r\n\r\n###`random( bytes, callback )`\r\n\r\n> Universal random provider. Generates cryptographically strong pseudo-random data.\r\n*Syncronous or Asyncronous*\r\n\r\n#### Params:\r\n  - **bytes**: Number. The number of bytes to return.\r\n  - **callback**: Function. The callback to call for async operation (optional)\r\n\r\n#### Returns:\r\n - A SlowBuffer; A buffer containing therandom bytes. (optional)\r\n\r\n---\r\n\r\n###`generateSalt( explicitIterations, callback )`\r\n\r\n> Convenience wrapper around `.random` to grab a new salt value.\r\n> Treat this value as opaque, as it captures iterations.\r\n>\r\n> Salt length varies based on SALT_SIZE and iterations. The default SALT_SIZE of 32 produces a value that is:\r\n>   (hashIterations.toString(16).length) + 1 + base64EncodedSalt.length) characters long (42 characters).\r\n>\r\n*Synchronous or Asynchronous*\r\n\r\n#### Params:\r\n - **explicitIterations**: Number. An integer (optional)\r\n - **callback**: Function. (optional)\r\n\r\n#### Returns:\r\n - A String. Return iterations and salt together as one string ({hex-iterations}.{base64-salt}) (optional)\r\n\r\n---\r\n\r\n###`secureHash( value, salt, callback )`\r\n\r\n> Alias for [`hash`](#hash-value-salt-callback-).\r\n\r\n---\r\n\r\n###`hash( value, salt, callback )`\r\n\r\n> Backs Secure hashes.\r\n> Uses PBKDF2 internally, as implemented by node's native crypto library.\r\n> See http://en.wikipedia.org/wiki/PBKDF2\r\n> and http://code.google.com/p/crypto-js/ for more information.\r\n*Asynchronous only*\r\n\r\n#### Params:\r\n - **value**: String. The plaintext value/password you want to hash.\r\n - **salt**: String. salt (should include iterations). Automatically created if omitted. (optional)\r\n - **callback**: Function. fn( {Error} err, {String} A secure hash (base64 encoded), {String} the original or newly created salt ).\r\n\r\n###`verify( salt, priorHash, value, callback )`\r\n\r\n> Verifies that the supplied plaintext `value` hashes to the same base64 encoded string as the `priorHash`, when hashed with\r\n> the same salt.\r\n> This method uses a constant-time string equality check to ensure information is not leaked via timing-attack.\r\n*Asynchronous only*\r\n\r\n#### Params:\r\n - **salt**: String. salt (should include iterations).\r\n - **priorHash**: String. A secure hash (base64 encoded).\r\n - **value**: String. The plaintext value/password you want to verify.\r\n - **callback**: Function. fn( {Error} err, {Boolean} True if the `value` matches the `priorHash`, false if not. ).\r\n\r\n## Issues\r\n\r\nPlease file them here: [https://github.com/davidmurdoch/easy-pbkdf2/issues](https://github.com/davidmurdoch/easy-pbkdf2/issues).\r\n\r\nAnd remember: pull requests are very welcome. :-)\r\n",
  "readmeFilename": "README.md",
  "_id": "easy-pbkdf2@0.1.1",
  "_from": "easy-pbkdf2@^0.1.1"
}
